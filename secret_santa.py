# streamlit_secretsanta_with_audit.py
import streamlit as st
import sqlite3
import pandas as pd
import os
from datetime import datetime

DB_PATH = "secretsanta.db"
ADMIN_PIN_ENV = "SECRETSANTA_ADMIN_PIN"

# ---------- DB helpers ----------
def get_conn():
    conn = sqlite3.connect(DB_PATH, timeout=10, isolation_level=None)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_conn()
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS participants (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        secret TEXT,
        assigned INTEGER DEFAULT 0
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS assignments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        drawer_name TEXT NOT NULL,
        recipient_name TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        revealed INTEGER DEFAULT 0,
        revealed_timestamp TEXT
    );
    """)
    c.execute("""
    CREATE TABLE IF NOT EXISTS logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        actor TEXT,
        action TEXT NOT NULL,
        details TEXT
    );
    """)

    # Migration: Add revealed columns if they don't exist
    try:
        c.execute("SELECT revealed FROM assignments LIMIT 1")
    except sqlite3.OperationalError:
        # Column doesn't exist, add it
        c.execute("ALTER TABLE assignments ADD COLUMN revealed INTEGER DEFAULT 0")
        c.execute("ALTER TABLE assignments ADD COLUMN revealed_timestamp TEXT")
        conn.commit()

    conn.commit()
    conn.close()

def log_event(conn, actor, action, details=""):
    """Insert a log row. Accepts an open conn to allow logging inside transactions."""
    ts = datetime.utcnow().isoformat() + "Z"
    c = conn.cursor()
    c.execute("INSERT INTO logs (timestamp, actor, action, details) VALUES (?, ?, ?, ?)",
              (ts, actor or '', action, details or ''))

def seed_participants_from_df(df: pd.DataFrame):
    conn = get_conn()
    c = conn.cursor()
    for _, row in df.iterrows():
        name = str(row['name']).strip()
        secret = str(row['secret']).strip() if 'secret' in row and not pd.isna(row['secret']) else ''
        if not name:
            continue
        try:
            c.execute("INSERT OR IGNORE INTO participants (name, secret) VALUES (?, ?)", (name, secret))
            log_event(conn, 'admin', 'seed_participant', f"seeded {name}")
        except Exception as e:
            st.error(f"DB error while inserting {name}: {e}")
    conn.commit()
    conn.close()

def list_participants():
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT name, secret, assigned FROM participants ORDER BY name")
    rows = c.fetchall()
    conn.close()
    return rows

def draw_random_recipient(drawer_name):
    """
    Reveal the pre-generated assignment for the drawer.
    No longer randomly assigns - all assignments must be pre-generated by admin.
    """
    conn = get_conn()
    c = conn.cursor()
    try:
        c.execute("BEGIN IMMEDIATE;")

        # Check if drawer exists
        c.execute("SELECT id FROM participants WHERE name = ?", (drawer_name,))
        drawer_row = c.fetchone()
        if not drawer_row:
            conn.rollback()
            log_event(conn, drawer_name, 'draw_failed', 'drawer not registered')
            return {"error": "Drawer not found in participant list."}

        # Look up their pre-generated assignment
        c.execute("SELECT recipient_name, timestamp, revealed, revealed_timestamp FROM assignments WHERE drawer_name = ?", (drawer_name,))
        assignment = c.fetchone()

        if not assignment:
            conn.rollback()
            log_event(conn, drawer_name, 'draw_failed_no_assignment', 'no pre-generated assignment found')
            return {"error": "No assignment found. Admin needs to generate assignments first."}

        recipient = assignment["recipient_name"]
        timestamp = assignment["timestamp"]
        already_revealed = assignment["revealed"]
        revealed_ts = assignment["revealed_timestamp"]

        if already_revealed:
            # Already revealed before, just show it again
            conn.commit()
            log_event(conn, drawer_name, 'view_existing_assignment', recipient)
            return {"recipient": recipient, "timestamp": timestamp, "revealed_timestamp": revealed_ts, "already_revealed": True}
        else:
            # First time revealing - mark as revealed
            reveal_ts = datetime.utcnow().isoformat() + "Z"
            c.execute("UPDATE assignments SET revealed = 1, revealed_timestamp = ? WHERE drawer_name = ?",
                      (reveal_ts, drawer_name))
            log_event(conn, drawer_name, 'draw_success', f"recipient={recipient}")
            conn.commit()
            return {"recipient": recipient, "timestamp": timestamp, "revealed_timestamp": reveal_ts, "already_revealed": False}

    except Exception as e:
        conn.rollback()
        log_event(conn, drawer_name, 'draw_exception', str(e))
        return {"error": f"DB transaction error: {e}"}
    finally:
        conn.close()


def validate_participant(name, secret):
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT secret FROM participants WHERE name = ?", (name,))
    row = c.fetchone()
    conn.close()
    if not row:
        return False, "Participant name not registered."
    registered_secret = row["secret"] or ""
    if registered_secret == "":
        return True, ""
    if secret == registered_secret:
        return True, ""
    else:
        return False, "Secret code does not match."

def reset_db():
    conn = get_conn()
    c = conn.cursor()
    c.execute("DELETE FROM assignments;")
    c.execute("UPDATE participants SET assigned = 0;")
    log_event(conn, 'admin', 'reset_assignments', 'all unassigned')
    conn.commit()
    conn.close()

def generate_all_assignments():
    """
    Pre-generate a complete Secret Santa cycle for all participants.
    Uses a circular derangement to ensure no one gets themselves.
    Clears existing assignments first.
    """
    conn = get_conn()
    c = conn.cursor()
    try:
        c.execute("BEGIN IMMEDIATE;")

        # Clear existing assignments
        c.execute("DELETE FROM assignments;")
        c.execute("UPDATE participants SET assigned = 0;")

        # Get all participants
        c.execute("SELECT name FROM participants ORDER BY name")
        participants = [r["name"] for r in c.fetchall()]

        if len(participants) < 2:
            conn.rollback()
            return {"error": "Need at least 2 participants to generate assignments."}

        # Create a shuffled copy for receivers
        import random
        receivers = participants.copy()

        # Shuffle until we get a valid derangement (no one gets themselves)
        # Using circular assignment is simpler: person[i] -> person[(i+1) % n]
        random.shuffle(receivers)

        # Rotate the receivers list by 1 to create circular assignment
        # This guarantees no one gets themselves (for n >= 2)
        receivers = receivers[1:] + receivers[:1]

        # Verify it's a valid derangement
        for i, giver in enumerate(participants):
            if giver == receivers[i]:
                # This shouldn't happen with circular assignment, but just in case
                conn.rollback()
                return {"error": "Failed to generate valid derangement. Try again."}

        # Insert all assignments
        ts = datetime.utcnow().isoformat() + "Z"
        for giver, receiver in zip(participants, receivers):
            c.execute("INSERT INTO assignments (drawer_name, recipient_name, timestamp) VALUES (?, ?, ?)",
                      (giver, receiver, ts))
            c.execute("UPDATE participants SET assigned = 1 WHERE name = ?", (receiver,))

        log_event(conn, 'admin', 'generate_all_assignments', f"generated {len(participants)} assignments")
        conn.commit()
        return {"success": True, "count": len(participants)}
    except Exception as e:
        conn.rollback()
        log_event(conn, 'admin', 'generate_assignments_error', str(e))
        return {"error": f"Failed to generate assignments: {e}"}
    finally:
        conn.close()

def remove_participant(name):
    """
    Remove a participant and regenerate all assignments.
    """
    conn = get_conn()
    c = conn.cursor()
    try:
        c.execute("DELETE FROM participants WHERE name = ?", (name,))
        log_event(conn, 'admin', 'remove_participant', name)
        conn.commit()
        conn.close()

        # Regenerate assignments
        return generate_all_assignments()
    except Exception as e:
        conn.rollback()
        conn.close()
        return {"error": f"Failed to remove participant: {e}"}

# ---------- Streamlit UI ----------
st.set_page_config(page_title="Secret Santa", layout="centered", initial_sidebar_state="collapsed")

init_db()

# Custom CSS for festive theme
st.markdown("""
<style>
    /* Hide Streamlit header and footer */
    header {
        background-color: #1B4332 !important;
        visibility: hidden;
    }

    .stApp > header {
        background-color: transparent !important;
    }

    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}

    /* Dark pine green background */
    .stApp {
        background-color: #1B4332;
        background-image: linear-gradient(180deg, #1B4332 0%, #2D6A4F 100%);
    }

    /* Snowfall animation */
    .snowflake {
        position: fixed;
        top: -10px;
        z-index: 9999;
        user-select: none;
        cursor: default;
        animation: snowfall linear infinite;
        color: white;
        font-size: 1em;
    }

    @keyframes snowfall {
        0% {
            transform: translateY(0vh) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(360deg);
            opacity: 0.8;
        }
    }

    /* Dancing Santa animation */
    @keyframes dance {
        0%, 100% { transform: translateY(0px) rotate(-5deg); }
        25% { transform: translateY(-20px) rotate(5deg); }
        50% { transform: translateY(0px) rotate(-5deg); }
        75% { transform: translateY(-10px) rotate(5deg); }
    }

    .dancing-santa {
        font-size: 120px;
        animation: dance 1s ease-in-out infinite;
        display: inline-block;
        margin: 20px auto;
    }

    /* Style text to be visible on dark background */
    .stMarkdown, .stText, p, span, div {
        color: #F1FAEE !important;
    }

    /* Style headers */
    h1{
        color: #E6BE9A !important;
    }
    h2, h3 {
        color: #E63946 !important;
    }
    /* Style buttons */
    .stButton > button {
        background-color: #E63946;
        color: white;
        border: none;
        border-radius: 25px;
        padding: 15px 40px;
        font-size: 20px;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        transition: all 0.3s;
    }

    .stButton > button:hover {
        background-color: #D62828;
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0,0,0,0.4);
    }

    /* Style input fields */
    .stTextInput > div > div > input {
        background-color: rgba(255, 255, 255, 0.9);
        color: #1B4332;
        border-radius: 10px;
    }

    /* Style expanders */
    .streamlit-expanderHeader {
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        color: #FFD700 !important;
    }

    /* Style success/error/warning messages */
    .stSuccess, .stError, .stWarning, .stInfo {
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
    }

    /* Welcome page styling */
    .welcome-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 50px 20px;
        min-height: 80vh;
    }

    .welcome-title {
        font-size: 60px;
        color: #FFD700;
        text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        margin-bottom: 20px;
    }

    /* Shhhh animation */
    @keyframes shhh {
        0%, 100% { opacity: 0; transform: scale(0.5); }
        50% { opacity: 1; transform: scale(1.2); }
    }

    .shhh-animation {
        font-size: 60px;
        animation: shhh 2s ease-in-out;
        text-align: center;
        margin: 30px 0;
        font-colour: E6BE9A;
    }

    /* Secret code reveal animation */
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .secret-reveal {
        animation: slideDown 0.5s ease-out;
    }
            
    /* Folded paper/chit styling */
    .paper-container {
        perspective: 1000px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 40px 0 20px 0;
        position: relative;
    }

    .folded-paper {
        width: 300px;
        height: 200px;
        background: linear-gradient(135deg, #FFF8DC 0%, #F5E6D3 100%);
        border-radius: 10px;
        box-shadow:
            0 10px 30px rgba(0,0,0,0.3),
            inset 0 0 20px rgba(0,0,0,0.1);
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
        border: 2px solid #D4AF37;
        margin-bottom: 20px;
    }

    .folded-paper:hover {
        transform: translateY(-10px) scale(1.05);
        box-shadow: 0 15px 40px rgba(0,0,0,0.4);
    }

    .folded-paper::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 2px;
        background: rgba(212, 175, 55, 0.3);
        transform: translateY(-50%);
    }

    .folded-paper::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 50%;
        width: 2px;
        background: rgba(212, 175, 55, 0.3);
        transform: translateX(-50%);
    }

    /* Opened paper animation */
    @keyframes unfold {
        0% {
            transform: rotateX(0deg);
            opacity: 1;
        }
        50% {
            transform: rotateX(90deg);
            opacity: 0.5;
        }
        100% {
            transform: rotateX(0deg);
            opacity: 1;
        }
    }

    .unfolding {
        animation: unfold 0.8s ease-out;
    }

    .opened-paper {
        background: linear-gradient(135deg, #FFF8DC 0%, #F5E6D3 100%);
        border: 3px solid #D4AF37;
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        max-width: 500px;
        margin: 20px auto;
    }

    .opened-paper h2 {
        color: #8B4513 !important;
        font-size: 48px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        margin: 20px 0;
    }

    .opened-paper p {
        color: #654321 !important;
        font-size: 18px;
    }

    /* Paper fold lines */
    .fold-line {
        position: absolute;
        background: rgba(139, 69, 19, 0.1);
    }
</style>
""", unsafe_allow_html=True)

# Add snowflakes
snowflakes_html = """
<div class="snowflakes" aria-hidden="true">
"""
for i in range(50):
    import random
    left = random.randint(0, 100)
    delay = random.uniform(0, 5)
    duration = random.uniform(10, 20)
    snowflakes_html += f'<div class="snowflake" style="left: {left}%; animation-duration: {duration}s; animation-delay: {delay}s;">‚ùÖ</div>'

snowflakes_html += "</div>"
st.markdown(snowflakes_html, unsafe_allow_html=True)

# Initialize session state
if "page" not in st.session_state:
    st.session_state.page = "welcome"

# ========== WELCOME PAGE ==========
if st.session_state.page == "welcome":
    # Add spacing at top
    st.markdown("<br><br>", unsafe_allow_html=True)

    # Title
    st.markdown('<h1 style="text-align: center; font-size: 60px; color: #FFD700; text-shadow: 3px 3px 6px rgba(0,0,0,0.5);">üéÑ Secret Santa üéÑ</h1>', unsafe_allow_html=True)

    # Dancing Santa
    st.markdown('<div style="text-align: center;"><div class="dancing-santa">üéÖ</div></div>', unsafe_allow_html=True)

    # Welcome text
    st.markdown("""
    <div style="text-align: center; color: #F1FAEE; font-size: 24px; margin: 30px 0;">
        <p>Welcome to the magical Secret Santa gift exchange!</p>
        <p style="font-size: 18px; margin-top: 20px;">
            üéÅ Draw your secret recipient<br>
            ‚ú® Keep the mystery alive<br>
            üéâ Spread holiday cheer
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Center the button using columns
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("üéÖ Let's Play! üéÅ", key="lets_play", use_container_width=True):
            st.session_state.page = "main"
            st.rerun()

# ========== MAIN APP ==========
elif st.session_state.page == "main":
    st.title("üéÖ Secret Santa Gift Exchange")

    tab1, tab2 = st.tabs(["üéÅ Draw Your Recipient", "üë§ Admin"])

    # ========== PARTICIPANT TAB ==========
    with tab1:
        # st.markdown("### üéÑ Discover Your Secret Recipient")

        # Initialize draw session states
        if "draw_step" not in st.session_state:
            st.session_state.draw_step = "name_input"
        if "draw_name" not in st.session_state:
            st.session_state.draw_name = ""
        if "draw_result" not in st.session_state:
            st.session_state.draw_result = None
        if "show_shhh" not in st.session_state:
            st.session_state.show_shhh = False

        # STEP 1: Name Input
        if st.session_state.draw_step == "name_input":
            st.markdown("## üéÅ Enter Your Name")
            st.write("Let's see who you'll be gifting to this holiday season!")

            name_input = st.text_input("Your name (as in participant list)", key="name_field", label_visibility="visible")

            if st.button("Continue ‚Üí", key="name_submit", use_container_width=True):
                if not name_input.strip():
                    st.warning("Please enter your name.")
                else:
                    # Check if name exists
                    conn = get_conn()
                    c = conn.cursor()
                    c.execute("SELECT id FROM participants WHERE name = ?", (name_input.strip(),))
                    exists = c.fetchone()
                    conn.close()

                    if not exists:
                        st.error("Name not found in participant list. Please check spelling.")
                    else:
                        st.session_state.draw_name = name_input.strip()
                        st.session_state.draw_step = "show_shhh"
                        st.session_state.show_shhh = True
                        st.rerun()

        # STEP 2: Shhh Animation + Secret Code Input
        elif st.session_state.draw_step == "show_shhh":
            # Show shhh animation
            if st.session_state.show_shhh:
                st.markdown('<div class="shhh-animation">ü§´ Shhh...</div>', unsafe_allow_html=True)
                st.markdown("<br>", unsafe_allow_html=True)

                # Center the continue button using columns
                col1, col2, col3 = st.columns([1, 1, 1])
                with col2:
                    if st.button("‚ú® Continue", key="continue_after_shhh", use_container_width=True):
                        st.session_state.show_shhh = False
                        st.rerun()
            else:
                # Show secret code input with animation
                st.markdown('<div class="secret-reveal">', unsafe_allow_html=True)
                st.markdown(f"#### üëã Hello, {st.session_state.draw_name}!")
                st.write("Now, enter your secret code to proceed...")

                secret_input = st.text_input("Secret Code", type="password", key="secret_field", placeholder="Enter your secret code")

                col1, col2 = st.columns([1, 1])
                with col1:
                    if st.button("‚Üê Back", key="back_to_name"):
                        st.session_state.draw_step = "name_input"
                        st.session_state.draw_name = ""
                        st.rerun()
                with col2:
                    if st.button("Verify ‚Üí", key="secret_submit", use_container_width=True):
                        if not secret_input:
                            st.warning("Please enter your secret code.")
                        else:
                            # Validate participant
                            ok, msg = validate_participant(st.session_state.draw_name, secret_input)
                            if not ok:
                                st.error(msg)
                                # log failed attempt
                                conn = get_conn()
                                log_event(conn, st.session_state.draw_name, 'validate_failed', msg)
                                conn.commit()
                                conn.close()
                            else:
                                # Get the assignment
                                conn = get_conn()
                                log_event(conn, st.session_state.draw_name, 'draw_attempt', '')
                                conn.commit()
                                conn.close()

                                result = draw_random_recipient(st.session_state.draw_name)
                                if "error" in result:
                                    st.error(result["error"])
                                else:
                                    st.session_state.draw_result = result
                                    st.session_state.draw_step = "show_paper"
                                    st.rerun()

                st.markdown('</div>', unsafe_allow_html=True)

        # STEP 3: Show Folded Paper
        elif st.session_state.draw_step == "show_paper":
            result = st.session_state.draw_result

            if result.get("already_revealed"):
                st.info("‚ú® Welcome back! You've already drawn your recipient.")
            else:
                st.success("üéâ Authentication successful!")

            st.markdown("### üìú Your Secret Santa Assignment Awaits...")
            st.write("Click the button inside the paper chit to reveal your recipient!")

            # Display the paper chit visual
            st.markdown("""
            <div class="paper-container">
                <div class="folded-paper">
                    <div style="font-size: 60px; color: #8B4513;">üìú</div>
                    <p style="color: #654321; font-weight: bold; margin-top: 10px; font-size: 18px;">Your Secret Assignment</p>
                </div>
            </div>
            """, unsafe_allow_html=True)

            # Regular button to open the paper
            col1, col2, col3 = st.columns([1, 1, 1])
            with col2:
                if st.button("üìú Open", key="paper_click", use_container_width=True):
                    st.session_state.draw_step = "paper_opened"
                    st.rerun()

            st.markdown("<br>", unsafe_allow_html=True)

            col1, col2, col3 = st.columns([1, 1, 1])
            with col2:
                if st.button("‚Üê Start Over", key="reset_draw", use_container_width=True):
                    st.session_state.draw_step = "name_input"
                    st.session_state.draw_name = ""
                    st.session_state.draw_result = None
                    st.rerun()

        # STEP 4: Paper Opened - Show Assignment
        elif st.session_state.draw_step == "paper_opened":
            result = st.session_state.draw_result

            st.markdown('<div class="unfolding">', unsafe_allow_html=True)

            # Opened paper with assignment
            st.markdown(f"""
            <div class="opened-paper">
                <div style="text-align: center;">
                    <p style="font-size: 20px; color: #8B4513 !important; margin-bottom: 10px;">üéÅ Your Secret Santa Recipient üéÅ</p>
                    <h2>{result["recipient"]}</h2>
                    <p style="margin-top: 20px; font-size: 16px;">
                        Remember: Keep it secret, keep it safe! ü§´<br>
                        <small style="font-size: 14px; color: #654321 !important;">
                            üìÖ Assignment created: {result["timestamp"]}<br>
                            üëÄ Revealed: {result["revealed_timestamp"]}
                        </small>
                    </p>
                </div>
            </div>
            """, unsafe_allow_html=True)

            st.markdown('</div>', unsafe_allow_html=True)

            st.markdown("<br>", unsafe_allow_html=True)

            col1, col2, col3, col4 = st.columns([1, 2, 2, 1])
            with col2:
                if st.button("üìú Close Paper", key="close_paper", use_container_width=True):
                    st.session_state.draw_step = "show_paper"
                    st.rerun()
            with col3:
                if st.button("‚ú® New Draw", key="new_draw", use_container_width=True):
                    st.session_state.draw_step = "name_input"
                    st.session_state.draw_name = ""
                    st.session_state.draw_result = None
                    st.rerun()

    # ========== ADMIN TAB ==========
    with tab2:
        st.markdown("### üîê Admin Control Panel")

        if not st.session_state.get("is_admin"):
            st.warning("üîí Admin authentication required")
            st.write("Enter your admin PIN to access admin functions.")

            admin_pin_input = st.text_input("Admin PIN", type="password", key="admin_pin")
            admin_pin_env = os.getenv(ADMIN_PIN_ENV, "")

            if st.button("üîì Authenticate", key="auth_btn"):
                if admin_pin_env and admin_pin_input == admin_pin_env:
                    st.session_state["is_admin"] = True
                    # log admin auth
                    conn = get_conn()
                    log_event(conn, 'admin', 'admin_auth', 'successful')
                    conn.commit()
                    conn.close()
                    st.success("‚úÖ Admin authenticated!")
                    st.rerun()
                else:
                    st.session_state["is_admin"] = False
                    st.error("‚ùå Admin PIN incorrect or not set on host.")
        else:
            st.success("‚úÖ Authenticated as Admin")

            if st.button("üö™ Logout", key="logout_btn"):
                st.session_state["is_admin"] = False
                st.rerun()

            st.divider()

            # Participant Management
            st.subheader("üë• Manage Participants")

            with st.expander("üì§ Seed from CSV", expanded=False):
                uploaded = st.file_uploader("Upload participants CSV (columns: name, secret)", type=["csv"], key="csv_upload")
                if uploaded is not None:
                    try:
                        df = pd.read_csv(uploaded)
                        if 'name' not in df.columns:
                            st.error("CSV missing 'name' column.")
                        else:
                            seed_participants_from_df(df)
                            st.success("‚úÖ Seeded participants (INSERT OR IGNORE).")
                    except Exception as e:
                        st.error(f"Failed to parse CSV: {e}")

            with st.expander("‚ûï Add Single Participant", expanded=False):
                new_name = st.text_input("Name to add", key="add_name")
                new_secret = st.text_input("Secret code (optional)", key="add_secret")
                if st.button("Add Participant", key="add_btn"):
                    if new_name.strip():
                        try:
                            conn = get_conn()
                            c = conn.cursor()
                            c.execute("INSERT OR IGNORE INTO participants (name, secret) VALUES (?, ?)",
                                      (new_name.strip(), new_secret.strip()))
                            log_event(conn, 'admin', 'add_participant', new_name.strip())
                            conn.commit()
                            conn.close()
                            st.success(f"‚úÖ Added {new_name.strip()}")
                        except Exception as e:
                            st.error(f"DB error: {e}")
                    else:
                        st.warning("Enter a name.")

            st.divider()

            # Assignment Generation
            st.subheader("üé≤ Generate Assignments")
            st.warning("‚ö†Ô∏è This creates a complete Secret Santa cycle. You won't be able to see who gets whom!")

            if st.button("‚ú® Generate All Assignments", type="primary", key="gen_btn"):
                result = generate_all_assignments()
                if "error" in result:
                    st.error(result["error"])
                else:
                    st.success(f"‚úÖ Generated {result['count']} assignments! Participants can now draw.")

            st.divider()

            # Remove Participant
            st.subheader("üóëÔ∏è Remove Participant")
            st.warning("‚ö†Ô∏è Removing a participant will regenerate ALL assignments!")

            participants_list = list_participants()
            if participants_list:
                participant_names = [p["name"] for p in participants_list]
                remove_name = st.selectbox("Select participant to remove", participant_names, key="remove_select")
                if st.button("üóëÔ∏è Remove and Regenerate", type="secondary", key="remove_btn"):
                    result = remove_participant(remove_name)
                    if "error" in result:
                        st.error(result["error"])
                    else:
                        st.success(f"‚úÖ Removed {remove_name} and regenerated {result['count']} assignments!")
            else:
                st.info("No participants to remove.")

            st.divider()

            # Reset
            st.subheader("üîÑ Reset Assignments")
            if st.button("üîÑ Clear All Assignments", key="reset_btn"):
                reset_db()
                st.success("‚úÖ All assignments cleared!")

            st.divider()

            # Download
            st.subheader("üì• Download Data")

            col1, col2 = st.columns(2)

            with col1:
                if st.button("üì• Download Participants CSV", key="dl_participants"):
                    rows = list_participants()
                    df = pd.DataFrame([{"name": r["name"], "secret": r["secret"], "assigned": r["assigned"]} for r in rows])
                    csv = df.to_csv(index=False)
                    st.download_button("Download", csv, file_name="participants.csv", mime="text/csv")

            with col2:
                if st.button("üì• Download Audit Logs CSV", key="dl_logs"):
                    conn = get_conn()
                    c = conn.cursor()
                    c.execute("SELECT timestamp, actor, action, details FROM logs ORDER BY id DESC LIMIT 1000")
                    logs = c.fetchall()
                    conn.close()
                    if logs:
                        df_logs = pd.DataFrame(logs, columns=['timestamp', 'actor', 'action', 'details'])
                        csv_logs = df_logs.to_csv(index=False)
                        st.download_button("Download", csv_logs, file_name="audit_logs.csv", mime="text/csv")
                    else:
                        st.info("No logs yet.")

            st.divider()

            # Audit Logs Viewer
            with st.expander("üìã View Audit Logs", expanded=False):
                conn = get_conn()
                c = conn.cursor()
                c.execute("SELECT timestamp, actor, action, details FROM logs ORDER BY id DESC LIMIT 100")
                logs = c.fetchall()
                conn.close()
                if logs:
                    df_logs = pd.DataFrame(logs, columns=['timestamp', 'actor', 'action', 'details'])
                    st.dataframe(df_logs, use_container_width=True)
                else:
                    st.info("No logs yet.")

    st.divider()
    st.caption("üîí Privacy: Assignments are stored server-side and hidden from everyone, including the admin. Keep this URL private!")

    # Show simple status counts
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT COUNT(*) as revealed FROM assignments WHERE revealed = 1")
    revealed_count = c.fetchone()["revealed"]
    c.execute("SELECT COUNT(*) as total FROM participants")
    total = c.fetchone()["total"]
    conn.close()

    waiting_count = total - revealed_count
    st.caption(f"Revealed: {revealed_count} ‚Ä¢ Waiting: {waiting_count}")
